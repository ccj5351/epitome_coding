#include "allHeaders.hpp"
#include "Dis_Bpp.h"
#include "quantizer.h"
#include <stdlib.h>     /* system, NULL, EXIT_FAILURE */

// /* What does this function do?
// * do different kinds compression to the residual images, including:
// * #0 : binary files generated by different uniform quantization levels (e.g., 0 - 100), then using lossless arithmetic compression to the binary files;
// * #1 : ".bmp" images generated by different uniform quantization levels (e.g., 0 - 100), then using lossless JPEG2000 compression to the bmp files;
// * #2 : ".bmp" images generated by 256-level (i.e., the most highest quality) uniform quantization, then using different quantization levels of JPEG2000 lossy compression to the bmp files;
// * #3 : ".bmp" images generated by 256-level (i.e., the most highest quality) uniform quantization, then using different quantization levels of JPEG lossy compression to the bmp files;
// */


// UNIFORM_QUANTIZATION
void Distortion_Bpp::uniQuan_0(
	const cv::Mat & input, 
	const cv::Mat & reconsInput,
	const string & binary_error_save_path,
	const string & final_recon_img_name,
	const bool & IsSaveImgFlag,
	double & psnr,
	double & mse,
	std::fstream * p_fs
	){
	doBinUniformQuantCodec(input, reconsInput, false, 1, binary_error_save_path, final_recon_img_name, IsSaveImgFlag, psnr, mse, p_fs);
}



// UNIFORM_QUANTIZATION_LOSSLESS_J2K
void Distortion_Bpp::uniQuan_1(
	const cv::Mat & input,
	const cv::Mat & reconsInput,
	const string & JPEG2K_EXE_Base_Path,
	const string & bin_header_error_save_path,
	const string & j2k_error_save_path,
	const string & de_error_save_path,
	const string & error_save_path,
	const string & final_recon_img_name,
	const bool & IsSaveImgFlag,
	double & psnr,
	double & mse,
	std::fstream * p_fs
	){

	// char compress_buffer[MAX_CHAR_NUM_OF_FILES_PATH];
	// char decompress_buffer[MAX_CHAR_NUM_OF_FILES_PATH];
	char * p_compress_buffer = new char[MAX_CHAR_NUM_OF_FILES_PATH];
	char *p_decompress_buffer = new char[MAX_CHAR_NUM_OF_FILES_PATH];

	char * char_error_save_path = new char[error_save_path.length() + 1]; // +1 due to the terminating null character "\0";
	std::strcpy(char_error_save_path, error_save_path.c_str());
	char * char_de_error_save_path = new char[de_error_save_path.length() + 1];
	std::strcpy(char_de_error_save_path, de_error_save_path.c_str());
	char * char_j2k_error_save_path = new char[j2k_error_save_path.length() + 1];
	std::strcpy(char_j2k_error_save_path, j2k_error_save_path.c_str());

	doBMPUniformQuantEncoder(input, reconsInput, false, 1, bin_header_error_save_path, error_save_path);

	// do JPEG2K compression
	/* function syntax: int system (const char* command);
	Execute system command
	Invokes the command processor to execute a command.
	If command is a null pointer, the function only checks whether a command processor is available through this function, without invoking any command.
	The effects of invoking a command depend on the system and library implementation, and may cause a program to behave in a non-standard manner or to terminate.
	Return Value:
	If command is a null pointer, the function returns a non-zero value in case a command processor is available and a zero value if it is not.
	If command is not a null pointer, the value returned depends on the system and library implementations,
	but it is generally expected to be the status code returned by the called command, if supported.
	*/
	//  #include <stdlib.h> /* system, NULL, EXIT_FAILURE */

	// JPEG2K compression, Lossless compression as default option
	// Usage: see https://code.google.com/p/openjpeg/wiki/DocJ2KCodec#Default_options
	// opj_compress -i <file> -o <file> -r <compression ratio>,<compression ratio>,...
	// A final lossless quality layer will be signified by the value 1. Default: 1 single lossless quality layer.

	string JPEG2K_Compress_Path = JPEG2K_EXE_Base_Path + "/" + "opj_compress.exe";
	string JPEG2K_Decompress_Path = JPEG2K_EXE_Base_Path + "/" + "opj_decompress.exe";
	char * char_JPEG2K_Compress_Path = new char[JPEG2K_Compress_Path.length() + 1];
	std::strcpy(char_JPEG2K_Compress_Path, JPEG2K_Compress_Path.c_str());
	char * char_JPEG2K_Decompress_Path = new char[JPEG2K_Decompress_Path.length() + 1];
	std::strcpy(char_JPEG2K_Decompress_Path, JPEG2K_Decompress_Path.c_str());

	std::sprintf(p_compress_buffer, "%s -i %s -o %s", char_JPEG2K_Compress_Path, char_error_save_path, char_j2k_error_save_path);
	std::sprintf(p_decompress_buffer, "%s -i %s -o %s", char_JPEG2K_Decompress_Path, char_j2k_error_save_path, char_de_error_save_path);
	// compress, from .bmp to .j2k;
	std::system(p_compress_buffer);
	// decompress, from .jk2 to .bmp;
	std::system(p_decompress_buffer);
	doBMPUniformQuantDecoder(input, reconsInput, bin_header_error_save_path, de_error_save_path, final_recon_img_name, IsSaveImgFlag, psnr, mse, p_fs);
	
	delete[] char_error_save_path;
	delete[] char_de_error_save_path;
	delete[] char_j2k_error_save_path;
	delete[] char_JPEG2K_Compress_Path;
	delete[] char_JPEG2K_Decompress_Path;
	delete[] p_decompress_buffer;
	delete[] p_compress_buffer;
}

// UNIFORM_QUANTIZATION_LOSSY_JPEG
void Distortion_Bpp::uniQuan_2(
	const cv::Mat & input,
	const cv::Mat & reconsInput,
	const string & final_recon_img_name,
	const string & bin_header_error_save_path,
	const string & jpg_error_save_path,
	const string & error_save_path,
	const bool & IsSaveImgFlag,
	double & psnr,
	double & mse,
	std::fstream * p_fs
	){
	// doBMPUniformQuantEncoder(input, reconsInput, true, 256, bin_header_error_save_path, error_save_path);
	// 0 <= QuantizationLevel <= 100, 
	// when QuantizationLevel = 100, means the highest quantization quality.
	int QuantizationLevel = 100;
	vector<int> v_jpegParams(2);
	v_jpegParams[0] = CV_IMWRITE_JPEG_QUALITY;
	v_jpegParams[1] = jpeg_quality;
	doBMPUniformQuantEncoder(input, reconsInput, true, QuantizationLevel, bin_header_error_save_path, error_save_path);
	cv::Mat mat_UniformQuantized = cv::imread(error_save_path, img_read_flag);
	if (mat_UniformQuantized.data == NULL)
		cout << "No image reading!" << endl;
	else{
		imwrite(jpg_error_save_path, mat_UniformQuantized, v_jpegParams);
		cv::Mat mat_JPG_UniformQuantized = cv::imread(jpg_error_save_path, img_read_flag);
		doBMPUniformQuantDecoder(input, reconsInput, bin_header_error_save_path, mat_JPG_UniformQuantized, final_recon_img_name, IsSaveImgFlag, psnr, mse, p_fs);
	}

	// delete possible indices of each xPatch in currently read image
	std::vector<int>().swap(v_jpegParams);
}

// UNIFORM_QUANTIZATION_LOSSY_J2K
void Distortion_Bpp::uniQuan_3(
	const cv::Mat & input,
	const cv::Mat & reconsInput,
	const string & JPEG2K_EXE_Base_Path,
	const string & bin_header_error_save_path,
	const string & j2k_error_save_path,
	const string & de_error_save_path,
	const string & error_save_path,
	const string & final_recon_img_name,
	const bool & IsSaveImgFlag,
	double & psnr,
	double & mse,
	std::fstream * p_fs
	){
	char * p_decompress_buffer = new char[MAX_CHAR_NUM_OF_FILES_PATH];
	char * p_compress_buffer = new char[MAX_CHAR_NUM_OF_FILES_PATH];

	// syntax: char * strcpy(char * destination, const char * source);
	// Copies the C string pointed by source into the array pointed by destination, 
	// including the terminating null character (and stopping at that point).
	char * char_error_save_path = new char[error_save_path.length() + 1];
	std::strcpy(char_error_save_path, error_save_path.c_str());
	char * char_de_error_save_path = new char[de_error_save_path.length() + 1];
	std::strcpy(char_de_error_save_path, de_error_save_path.c_str());
	char * char_j2k_error_save_path = new char[j2k_error_save_path.length() + 1];
	std::strcpy(char_j2k_error_save_path, j2k_error_save_path.c_str());


	// 0 <= QuantizationLevel <= 100, 
	// when QuantizationLevel = 100, means the highest quantization quality.
	int QuantizationLevel = 100;
	doBMPUniformQuantEncoder(input, reconsInput, true, QuantizationLevel, bin_header_error_save_path, error_save_path);

	string JPEG2K_Compress_Path = JPEG2K_EXE_Base_Path + "/" + "opj_compress.exe";
	string JPEG2K_Decompress_Path = JPEG2K_EXE_Base_Path + "/" + "opj_decompress.exe";
	int J2K_Compression_Ratio = 101 - jpeg_quality; // e.g., jpeg_quality belongs to [5, 100]
	// that means J2K_Compression_Ratio belongs to [1, 96];
	string s_J2K_Compression_Ratio = to_string(static_cast<long long>(J2K_Compression_Ratio));

	char * char_J2K_Compression_Ratio = new char[s_J2K_Compression_Ratio.length() + 1];
	std::strcpy(char_J2K_Compression_Ratio, s_J2K_Compression_Ratio.c_str());
	char * char_JPEG2K_Compress_Path = new char[JPEG2K_Compress_Path.length() + 1];
	std::strcpy(char_JPEG2K_Compress_Path, JPEG2K_Compress_Path.c_str());
	char * char_JPEG2K_Decompress_Path = new char[JPEG2K_Decompress_Path.length() + 1];
	std::strcpy(char_JPEG2K_Decompress_Path, JPEG2K_Decompress_Path.c_str());

	sprintf(p_compress_buffer, "%s -i %s -o %s -r %s", char_JPEG2K_Compress_Path, char_error_save_path, char_j2k_error_save_path, char_J2K_Compression_Ratio);
	sprintf(p_decompress_buffer, "%s -i %s -o %s", char_JPEG2K_Decompress_Path, char_j2k_error_save_path, char_de_error_save_path);
	// compress, from .bmp to .j2k;
	std::system(p_compress_buffer);
	// decompress, from .jk2 to .bmp;
	std::system(p_decompress_buffer);
	doBMPUniformQuantDecoder(input, reconsInput, bin_header_error_save_path, de_error_save_path, final_recon_img_name, IsSaveImgFlag, psnr, mse, p_fs);

	delete[] char_error_save_path;
	delete[] char_de_error_save_path;
	delete[] char_j2k_error_save_path;
	delete[] char_J2K_Compression_Ratio;
	delete[] char_JPEG2K_Compress_Path;
	delete[] char_JPEG2K_Decompress_Path;
	delete[] p_decompress_buffer;
	delete[] p_compress_buffer;
}

void Distortion_Bpp::CompressReconToEpiRecons(
	const string JPEG2K_EXE_Base_Path, // JPEG2K compressor and de-compressor base path
	const COMPRE_FLAG_2_EPI_RECON compres_flag_2_epi_recon
	){
	// to get the file lists of each input image category,
	// and we should manually guarantee that input images and reconstructed images have the almost same filelist, 
	// just with a constant difference, like "recon-",
	// which makes they can be read via the same string variable.
	vector<string> reconsParamCategories, filelist;
	GetDirList(EpitomeResultDir, &reconsParamCategories);
	GetFileList(DatabaseDir, &filelist);
	int fileListSize = filelist.size();


	// /* check the string is 1-, 2-, or 3-character length, and to make them be 3-character length, if less than 3.
	//    i.e., change '5' to '005', and '15' to '015'; 
	//    Usage: std::string str ("Test string");
	//    std::cout << "The size of str is " << str.length() << " bytes.\n";
	// */
	// number of chars control
	char c_jpeg_quality[10];
	std::sprintf(c_jpeg_quality, "%03d", jpeg_quality);
	string s_jpeg_q(c_jpeg_quality);
	string fileStreamForErrorImgSize = ReconsCompresDir + "/" + "errorImgSize-cq-" + s_jpeg_q + "-" + get_curr_date() + ".txt";
	ofstream fout_errorImgSize(fileStreamForErrorImgSize, std::ofstream::app);
	if (!fout_errorImgSize){
		std::cout << "File Not Opened" << endl;
	}
	s_jpeg_q = "cq-" + s_jpeg_q;

	MakeDir(ReconsCompresDir + "/" + s_jpeg_q);

	int reconsParamCategorySize = reconsParamCategories.size();

	for (int paramCategoryIdx = 0; paramCategoryIdx != reconsParamCategorySize; ++paramCategoryIdx){ // for different cases of epitome size and xPatch side_length

		fout_errorImgSize << s_jpeg_q + " -- " + reconsParamCategories[paramCategoryIdx] + "::" << endl;

		// different patchSpacing parameters
		// e.g., recon-4_0-Edwin-less-try
		// e.g., recon-4_1-Edwin-less-try
		vector<string> patchSpacingParams;
		GetDirList(EpitomeResultDir + "/" + reconsParamCategories[paramCategoryIdx], &patchSpacingParams);
		int size_patchSpacingParams = patchSpacingParams.size();
		for (int patchSpacingParamsIdx = 0; patchSpacingParamsIdx != size_patchSpacingParams; ++patchSpacingParamsIdx){// for different cases of patchSpacingParams
			// string std::string::substr (size_t pos = 0, size_t len = npos) const;
			// Returns a newly constructed string object with its value initialized to a copy of a substring of this object.
			// The substring is the portion of the object that starts at character position pos and spans len characters(or until the end of the string, whichever comes first).
			string s_patchSpacingParams = patchSpacingParams[patchSpacingParamsIdx].substr(6, 3); // 3 means that length = 3
			// make directories for saving the final compressed reconstruction images
			string tempDir = ReconsCompresDir + "/" + s_jpeg_q + "/" + reconsParamCategories[paramCategoryIdx]
				+ "-" + s_patchSpacingParams + "-UniQunti-" + to_string(static_cast<long long>(compres_flag_2_epi_recon));
			fout_errorImgSize << "  " << s_patchSpacingParams << " -- Uniform Quantization-" 
				<< to_string(static_cast<long long>(compres_flag_2_epi_recon)) << " - error images size - ";
			MakeDir(tempDir);
			string fs_path = tempDir + "/" + "psnr_rmse_results.txt";
			std::fstream fs(fs_path, std::fstream::in | std::fstream::app);

			uintmax_t errImgSize;
			// the vector of PSNR and MSE,
			// and to calculate the average PSNR and average MSE;
			vector <double> v_psnr(fileListSize, .0), v_mse(fileListSize, .0);

			for (unsigned int fileIdx = 0; fileIdx != fileListSize; ++fileIdx){
				
				const bool IsSaveImgFlag = fileIdx < std::min<int>(save_img_number, fileListSize) ? true : false;
				// read input image
				Mat_<double> input = imread(DatabaseDir + "/" + filelist[fileIdx], img_read_flag); // read gray images
				const string tempImgName = filelist[fileIdx];
				std::size_t pos = tempImgName.find(".");
				string imageNameNoFileExtension = tempImgName.substr(0, pos);

				// read reconstructed image
				// first check the file name extension
				// setFileExtension(filelist[fileIdx], encodeTypeforReconsImgs);
				Mat_<double> reconsInput = imread(EpitomeResultDir + "/" + reconsParamCategories[paramCategoryIdx] + "/"
					+ patchSpacingParams[patchSpacingParamsIdx] + "/"
					+ nameDifference + imageNameNoFileExtension + encodeTypeforReconsImgs, img_read_flag);

				// do some normalization for the following compression and saving
				if (!input.data){
					std::cout << "Cannot read Input image " << DatabaseDir << "/" << tempImgName << endl;
				}
				if (!reconsInput.data){
					std::cout << "Cannot read reconsInput image " << EpitomeResultDir << "/" << reconsParamCategories[paramCategoryIdx] << "/"
						<< patchSpacingParams[patchSpacingParamsIdx] << "/"
						<< nameDifference + imageNameNoFileExtension + encodeTypeforReconsImgs << endl;
				}

				// Mat_<double> error(input.rows, input.cols);
				Mat_<double> error = Mat_<double>(input - reconsInput);

				// keep the max and min values of error, before normalization.
				double max_intensity, min_intensity;
				minMaxLoc(error, &min_intensity, &max_intensity);
				
#ifdef _DEBUG
				cout << "Normalized_error :\n";
				display_n_by_n_elements(error, 10);
#endif

				if (!fs.is_open()){
					cout << "Cannot open " << fs_path << endl;
				}
				else {
					fs << "Image " << fileIdx << " ---- " << imageNameNoFileExtension << "PSNR & MSE Results:" << endl;
				}

				// final reconstruction result from epitome reconstruction and uniform quantization of residual images.
				string  final_recon_img_name = tempDir + "/" + nameDifference + imageNameNoFileExtension + encodeTypeforReconsImgs;
				switch (compres_flag_2_epi_recon){
				case UNIFORM_QUANTIZATION:{ // #0
					// make a directory for the error images, whose sizes are needed for the following rate-distortion calculation.
					string nameErrorImgsDir = tempDir + "/" + "error-bin";
					// here we make a separate directory for those recon_error images, just because it is easy to measure their total sizes,
					// when they are in the same directory.
					MakeDir(nameErrorImgsDir);
					string binary_error_save_path = nameErrorImgsDir + "/" + "error-" + imageNameNoFileExtension + ".bin";

					uniQuan_0(input, reconsInput, binary_error_save_path, final_recon_img_name, IsSaveImgFlag, v_psnr[fileIdx], v_mse[fileIdx], &fs);
					if (fileIdx == fileListSize - 1){
						errImgSize = getFileSizeFromDir(nameErrorImgsDir);
						fout_errorImgSize << "Uncompressed Binary " << errImgSize << " Bytes.\n";
					}
				}
					break;

				case UNIFORM_QUANTIZATION_LOSSLESS_J2K:{ // # 1
					// make a directory for the error images, whose sizes are needed for the following rate-distortion calculation.
					string JPEG2K_ErrorImgsDir = tempDir + "/" + "error-JPEG2K";
					MakeDir(JPEG2K_ErrorImgsDir);
					string J2KImgsSubDir = JPEG2K_ErrorImgsDir + "/" + "error-J2K";
					MakeDir(J2KImgsSubDir);

					string bin_header_error_save_path = J2KImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".bin";
					string j2k_error_save_path = J2KImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".j2k";
					string error_save_path = JPEG2K_ErrorImgsDir + "/" + "error-" + imageNameNoFileExtension + ".bmp";
					string de_error_save_path = JPEG2K_ErrorImgsDir + "/" + "de-error-" + imageNameNoFileExtension + ".bmp";

					uniQuan_1(input, reconsInput, JPEG2K_EXE_Base_Path, bin_header_error_save_path, j2k_error_save_path, de_error_save_path,
						error_save_path, final_recon_img_name, IsSaveImgFlag, v_psnr[fileIdx], v_mse[fileIdx], &fs);
					
					if (fileIdx == fileListSize - 1){
						errImgSize = getFileSizeFromDir(J2KImgsSubDir);
						fout_errorImgSize << "Lossless JPEG2K residual and binary headers " << errImgSize << " Bytes.\n";
					}

				}
					break;

				case UNIFORM_QUANTIZATION_LOSSY_JPEG:{ // # 2

					// make a directory for the error images, whose sizes are needed for the following rate-distortion calculation.
					string JPEG_ErrorImgsDir = tempDir + "/" + "error-JPEG";
					MakeDir(JPEG_ErrorImgsDir);
					string JPGImgsSubDir = JPEG_ErrorImgsDir + "/" + "error-JPG-lossy";
					MakeDir(JPGImgsSubDir);
					string bin_header_error_save_path = JPGImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".bin";
					string jpg_error_save_path = JPGImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".jpg";
					string error_save_path = JPEG_ErrorImgsDir + "/" + "error-" + imageNameNoFileExtension + ".bmp";
					uniQuan_2(input, reconsInput, final_recon_img_name, bin_header_error_save_path, jpg_error_save_path, error_save_path, 
						IsSaveImgFlag, v_psnr[fileIdx], v_mse[fileIdx], &fs);
					if (fileIdx == fileListSize - 1){
							errImgSize = getFileSizeFromDir(JPGImgsSubDir);
							fout_errorImgSize << "Lossy JPEG residual and binary headers " << errImgSize << " Bytes.\n";
						}
				}
					break;


				case UNIFORM_QUANTIZATION_LOSSY_J2K:{ // # 3
					// make a directory for the error images, whose sizes are needed for the following rate-distortion calculation.
					string JPEG2K_ErrorImgsDir = tempDir + "/" + "error-JPEG2K-lossy";
					MakeDir(JPEG2K_ErrorImgsDir);
					string J2KImgsSubDir = JPEG2K_ErrorImgsDir + "/" + "error-J2K-lossy";
					MakeDir(J2KImgsSubDir);

					string bin_header_error_save_path = J2KImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".bin";
					string j2k_error_save_path = J2KImgsSubDir + "/" + "error-" + imageNameNoFileExtension + ".j2k";
					string error_save_path = JPEG2K_ErrorImgsDir + "/" + "error-" + imageNameNoFileExtension + ".bmp";
					string de_error_save_path = JPEG2K_ErrorImgsDir + "/" + "de-error-" + imageNameNoFileExtension + ".bmp";
					uniQuan_3(input, reconsInput, JPEG2K_EXE_Base_Path, bin_header_error_save_path, j2k_error_save_path, de_error_save_path,
						error_save_path, final_recon_img_name, IsSaveImgFlag, v_psnr[fileIdx], v_mse[fileIdx], &fs);

					if (fileIdx == fileListSize - 1){
						errImgSize = getFileSizeFromDir(J2KImgsSubDir);
						fout_errorImgSize << "Lossy JPEG2K residual and binary headers " << errImgSize << " Bytes.\n";
					}
				}
					break;

				default:
					cout << "Wrong parameters input, and there are only 4 categories of residual compression." << endl;

				} /*end of switch-case*/
				
				// cv::Mat will free memory only if it was allocated by create method (if Mat object owns this memory):
				// release the Mat variable
				// e.g., Mat src = imread("1.tif");
				// src.release(); // free memory
				input.release();
				reconsInput.release();
				error.release();

			} /*end of each image*/
			double ave_psnr = vector_average(v_psnr);
			double ave_mse  = vector_average(v_mse);
			if (!fs.is_open()){
				cout << "Cannot open " << fs_path << endl;
			}
			else {
				fs << "Average PSNR of " << fileListSize << " images is ---- " << ave_psnr  <<  endl
					<< "Average MSE of " << fileListSize << " images is ---- " << ave_mse << endl;
			}

			// release memory
			vector<double>().swap(v_psnr);
			vector<double>().swap(v_mse);
			fs.close();
		}/*end of patchSpacingParams */
		std::vector<string>().swap(patchSpacingParams);

	}/*end of  reconsParamCategories*/
	fout_errorImgSize.close();

	// release memory
	std::vector<string>().swap(reconsParamCategories);
	std::vector<string>().swap(filelist);
}